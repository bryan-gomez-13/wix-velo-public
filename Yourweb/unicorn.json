{
    "history": [
        {
            "breakpoints": [],
            "visible": true,
            "aspectRatio": 1,
            "userDownsample": 1,
            "layerType": "effect",
            "type": "gradient",
            "usesPingPong": false,
            "speed": 0.25,
            "trackMouse": 0,
            "trackAxes": "xy",
            "mouseMomentum": 0,
            "texture": false,
            "animating": false,
            "isMask": 0,
            "compiledFragmentShaders": [
                "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0, 0, 0);\ncase 1: return vec3(0, 0, 0);\ncase 2: return vec3(0, 0, 0);\ncase 3: return vec3(0, 0, 0);\ncase 4: return vec3(0, 0, 0);\ncase 5: return vec3(0, 0, 0);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0, 0, 0);\n}void main() {vec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nuv -= pos;\nuv /= max(0.5000*2., 1e-5);\nuv = rotate(uv, (0.0000 - 0.5) * 2. * PI);\nvec4 color = vec4(getColor(uv), 1.0000);\nfragColor = color;\n}"
            ],
            "compiledVertexShaders": [
                "#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"
            ],
            "data": {
                "downSample": 0.5,
                "depth": false,
                "uniforms": {},
                "isBackground": true
            },
            "id": "gradient"
        },
        {
            "breakpoints": [],
            "visible": true,
            "aspectRatio": 1,
            "userDownsample": 1,
            "layerType": "effect",
            "type": "wisps",
            "usesPingPong": false,
            "speed": 0.25,
            "trackMouse": 0.11,
            "trackAxes": "xy",
            "mouseMomentum": 0.8,
            "texture": false,
            "animating": true,
            "isMask": 0,
            "compiledFragmentShaders": [
                "#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src + dst;\n}out vec4 fragColor;\nconst float PI = 3.14159265359;\nmat2 rot(float a) {\nreturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}vec2 hash(vec2 p) {\np = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\nreturn -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}float luma(vec3 color) {\nreturn dot(color, vec3(0.299, 0.587, 0.114));\n}float voronoi_additive(vec2 st, float radius, vec2 mouse_pos, float scale) {\nvec2 i_st = floor(st);\nvec2 f_st = fract(st);float wander = 0.0000 * uTime * 0.2;\nfloat total_contribution = 0.0;for (int y = -2; y <= 2; y++) {\nfor (int x = -2; x <= 2; x++) {\nvec2 neighbor = vec2(float(x), float(y));\nvec2 cell_id = i_st + neighbor;\nvec2 point = hash(cell_id);\npoint = 0.5 + 0.5 * sin(5. + wander + 6.2831 * point);\nvec2 starAbsPos = cell_id + point;\nvec2 dirToMouse = mouse_pos - starAbsPos;\nfloat distToMouse = length(dirToMouse);\nfloat attractStrength = 0.9000 * exp(-distToMouse * mix(2.0 + 1.0000 * 2., 0.5, 0.5000)) * 2.;\nstarAbsPos += dirToMouse * attractStrength;\nvec2 diff = starAbsPos - st;\nfloat dist = length(diff);float contribution = radius / max(dist, radius * 0.1);\nfloat shimmer_phase = dot(point, vec2(1.0)) * 10. + hash(cell_id).x * 5.0 + uTime * 0.5;\nfloat shimmer = mix(1., (sin(shimmer_phase) + 1.), 0.5000);\ncontribution *= shimmer;\ntotal_contribution += mix(contribution*contribution, contribution * 2., 0.2500);\n}\n}return total_contribution;\n}vec4 randomStyle() {\nvec2 uv = vTextureCoord;vec4 bg = texture(uTexture, uv);vec4 color = vec4(0.0);\nvec2 aspectRatio = vec2(uResolution.x / uResolution.y, 1.0);vec2 mPos = mix(vec2(0.0), (uMousePos - 0.5), 0.1100);uv -= vec2(0.5, 0.5);\nuv *= aspectRatio;\nuv = uv * rot(0.2500 * 2.0 * PI);\nuv *= 40.0 * 1.0000;\nuv *= mix(vec2(1.0), vec2(1.0, 0.0), 0.9700);\nuv /= aspectRatio;mPos = mPos * rot(0.2500 * 2.0 * PI);vec2 mouseGrid = uMousePos;\nmouseGrid -= vec2(0.5, 0.5);\nmouseGrid *= aspectRatio;\nmouseGrid = mouseGrid * rot(0.2500 * 2.0 * PI);\nmouseGrid *= 40.0 * 1.0000;\nmouseGrid *= mix(vec2(1.0), vec2(1.0, 0.0), 0.9700);\nmouseGrid /= aspectRatio;vec2 movementOffset = vec2(0.0, uTime * 0.5000 * -0.05);\nvec2 mouseGrid1 = mouseGrid - (mPos * 38.0 * 1.0000) + movementOffset;\nvec2 mouseGrid2 = mouseGrid - (mPos * 48.0 * 1.0000) + movementOffset;vec2 st1 = uv - (mPos * 38.0 * 1.0000);\nvec2 st2 = uv - (mPos * 48.0 * 1.0000);vec2 mouse1 = st1 + vec2(0.0, uTime * 0.5000 * -0.05);\nvec2 mouse2 = st2 + vec2(0.0, uTime * 0.5000 * -0.05);float radius1 = 0.5 * 0.5000;\nfloat radius2 = 0.5 * 0.5000;float pass1 = voronoi_additive(mouse1 * aspectRatio, radius1, mouseGrid1 * aspectRatio, 38.0 * 1.0000);\nfloat pass2 = voronoi_additive(mouse2 * aspectRatio + vec2(10), radius2, mouseGrid2 * aspectRatio + vec2(10.0), 48.0 * 1.0000);pass1 *= 0.02;\npass2 *= 0.04;color.rgb = (pass1 + pass2) * vec3(0.00392156862745098, 0.18823529411764706, 0.09019607843137255) * mix(1.0, bg.r, 0.0500);\ncolor.rgb = clamp(color.rgb, 0.0, 1.0);color.rgb = blend(1, bg.rgb, color.rgb);color = vec4(color.rgb, max(bg.a, luma(color.rgb)));\nreturn color;\n}void main() {\nvec4 color;color = randomStyle();\nfragColor = color;}"
            ],
            "compiledVertexShaders": [
                "#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"
            ],
            "data": {
                "depth": false,
                "uniforms": {},
                "isBackground": false
            },
            "id": "wisps"
        },
        {
            "breakpoints": [],
            "visible": true,
            "aspectRatio": 1,
            "userDownsample": 1,
            "layerType": "effect",
            "type": "wisps",
            "usesPingPong": false,
            "speed": 0.25,
            "trackMouse": 0.11,
            "trackAxes": "xy",
            "mouseMomentum": 0.8,
            "texture": false,
            "animating": true,
            "isMask": 0,
            "compiledFragmentShaders": [
                "#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src + dst;\n}out vec4 fragColor;\nconst float PI = 3.14159265359;\nmat2 rot(float a) {\nreturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}vec2 hash(vec2 p) {\np = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\nreturn -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}float luma(vec3 color) {\nreturn dot(color, vec3(0.299, 0.587, 0.114));\n}float voronoi_additive(vec2 st, float radius, vec2 mouse_pos, float scale) {\nvec2 i_st = floor(st);\nvec2 f_st = fract(st);float wander = 0.0000 * uTime * 0.2;\nfloat total_contribution = 0.0;for (int y = -2; y <= 2; y++) {\nfor (int x = -2; x <= 2; x++) {\nvec2 neighbor = vec2(float(x), float(y));\nvec2 cell_id = i_st + neighbor;\nvec2 point = hash(cell_id);\npoint = 0.5 + 0.5 * sin(5. + wander + 6.2831 * point);\nvec2 starAbsPos = cell_id + point;\nvec2 dirToMouse = mouse_pos - starAbsPos;\nfloat distToMouse = length(dirToMouse);\nfloat attractStrength = 0.9000 * exp(-distToMouse * mix(2.0 + 0.5100 * 2., 0.5, 0.5000)) * 2.;\nstarAbsPos += dirToMouse * attractStrength;\nvec2 diff = starAbsPos - st;\nfloat dist = length(diff);float contribution = radius / max(dist, radius * 0.1);\nfloat shimmer_phase = dot(point, vec2(1.0)) * 10. + hash(cell_id).x * 5.0 + uTime * 0.5;\nfloat shimmer = mix(1., (sin(shimmer_phase) + 1.), 0.5000);\ncontribution *= shimmer;\ntotal_contribution += mix(contribution*contribution, contribution * 2., 0.2500);\n}\n}return total_contribution;\n}vec4 randomStyle() {\nvec2 uv = vTextureCoord;vec4 bg = texture(uTexture, uv);vec4 color = vec4(0.0);\nvec2 aspectRatio = vec2(uResolution.x / uResolution.y, 1.0);vec2 mPos = mix(vec2(0.0), (uMousePos - 0.5), 0.1100);uv -= vec2(0.5, 0.5);\nuv *= aspectRatio;\nuv = uv * rot(0.4401 * 2.0 * PI);\nuv *= 40.0 * 0.5100;\nuv *= mix(vec2(1.0), vec2(1.0, 0.0), 0.8200);\nuv /= aspectRatio;mPos = mPos * rot(0.4401 * 2.0 * PI);vec2 mouseGrid = uMousePos;\nmouseGrid -= vec2(0.5, 0.5);\nmouseGrid *= aspectRatio;\nmouseGrid = mouseGrid * rot(0.4401 * 2.0 * PI);\nmouseGrid *= 40.0 * 0.5100;\nmouseGrid *= mix(vec2(1.0), vec2(1.0, 0.0), 0.8200);\nmouseGrid /= aspectRatio;vec2 movementOffset = vec2(0.0, uTime * 0.5000 * -0.05);\nvec2 mouseGrid1 = mouseGrid - (mPos * 38.0 * 0.5100) + movementOffset;\nvec2 mouseGrid2 = mouseGrid - (mPos * 48.0 * 0.5100) + movementOffset;vec2 st1 = uv - (mPos * 38.0 * 0.5100);\nvec2 st2 = uv - (mPos * 48.0 * 0.5100);vec2 mouse1 = st1 + vec2(0.0, uTime * 0.5000 * -0.05);\nvec2 mouse2 = st2 + vec2(0.0, uTime * 0.5000 * -0.05);float radius1 = 0.5 * 0.5100;\nfloat radius2 = 0.5 * 0.5100;float pass1 = voronoi_additive(mouse1 * aspectRatio, radius1, mouseGrid1 * aspectRatio, 38.0 * 0.5100);\nfloat pass2 = voronoi_additive(mouse2 * aspectRatio + vec2(10), radius2, mouseGrid2 * aspectRatio + vec2(10.0), 48.0 * 0.5100);pass1 *= 0.02;\npass2 *= 0.04;color.rgb = (pass1 + pass2) * vec3(0.6313725490196078, 0, 0.4588235294117647) * mix(1.0, bg.r, 0.7900);\ncolor.rgb = clamp(color.rgb, 0.0, 1.0);color.rgb = blend(1, bg.rgb, color.rgb);color = vec4(color.rgb, max(bg.a, luma(color.rgb)));\nreturn color;\n}void main() {\nvec4 color;color = randomStyle();\nfragColor = color;}"
            ],
            "compiledVertexShaders": [
                "#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"
            ],
            "data": {
                "depth": false,
                "uniforms": {},
                "isBackground": false
            },
            "id": "wisps1"
        },
        {
            "breakpoints": [],
            "visible": true,
            "aspectRatio": 1,
            "userDownsample": 1,
            "layerType": "effect",
            "type": "polar",
            "usesPingPong": false,
            "speed": 0.25,
            "trackMouse": 0,
            "trackAxes": "xy",
            "mouseMomentum": 0,
            "texture": false,
            "animating": true,
            "isMask": 0,
            "compiledFragmentShaders": [
                "#version 300 es\nprecision mediump float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;out vec4 fragColor;const float PI = 3.1415926;vec2 polar(vec2 uv, vec2 pos) {\nuv -= pos;\nfloat angle = atan(uv.y, uv.x);\nfloat radius = length(uv);float xCoord = mod((angle + 0.0000 * 2.0 * PI) + (uTime * 0.05) + PI, 2.0 * PI) / (2.0 * PI);\nfloat yCoordRaw = radius * 1.0000;\nfloat gamma = pow(2.0, (0.1000 - 0.5) * 4.0);\nfloat yCoord = pow(fract(yCoordRaw), gamma);return fract(vec2(yCoord, xCoord));\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1);\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 polarCoord = polar(uv * aspectRatio, pos * aspectRatio);\nvec4 color1 = texture(uTexture, polarCoord);\nvec2 oppositePolar = vec2(polarCoord.x, polarCoord.y > 0.5 ? polarCoord.y - 0.5 : polarCoord.y + 0.5);\nvec4 color2 = texture(uTexture, oppositePolar);\nfloat seamBlend = 0.0;\nfloat blendWidth = 1.0000 * 0.1;\nif (polarCoord.y < blendWidth || polarCoord.y > 1.0 - blendWidth) {\nif (polarCoord.y < blendWidth) {\nseamBlend = 1.0 - (polarCoord.y / blendWidth);\n} else {\nseamBlend = (polarCoord.y - (1.0 - blendWidth)) / blendWidth;\n}\nseamBlend = smoothstep(0.0, 1.0, seamBlend);\n}\nfragColor = mix(color1, color2, seamBlend);\n}"
            ],
            "compiledVertexShaders": [
                "#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"
            ],
            "data": {
                "depth": false,
                "uniforms": {},
                "isBackground": false
            },
            "id": "polar"
        },
        {
            "breakpoints": [],
            "visible": true,
            "aspectRatio": 1,
            "userDownsample": 1,
            "layerType": "effect",
            "type": "texturize",
            "usesPingPong": false,
            "speed": 0.16,
            "texture": false,
            "animating": true,
            "mouseMomentum": 0,
            "isMask": 0,
            "compiledFragmentShaders": [
                "#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}\nout vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nfloat timeRand1 = randFibo(vec2(floor(uTime * 0.5) * 2. + 0.001, 0.5));\nfloat timeRand2 = randFibo(vec2(floor(uTime * 0.5) * 2. + 1.001, 0.5));\nfloat sizeX = 0.0300 * 0.2 * timeRand1;\nfloat sizeY = 0.0300 * 0.2 * timeRand2;\nfloat floorY = floor(uv.y/sizeY) + 0.005;\nfloat floorX = floor(uv.x/sizeX) + 0.005;\nfloat phase = 0.0100 * 0.01;\nfloat chromab = 0.1300 * 0.75;\nfloat offset = 0.;vec2 blockSize = vec2(50.0, 50.0) * (1.0 - 0.0300);\nvec2 blockUV = floor(uv * blockSize) / blockSize;\nfloat blockRand = randFibo(blockUV);\nfloat blockTimeRand = timeRand1;\nfloat blockNoise = mix(\n1.,\nstep(0.8, randFibo(vec2(blockTimeRand, blockRand))),\n0.9400\n);float offsetX = 0.7100 * 0.5 * blockNoise;\nfloat offsetY = 0.2200 * 0.5 * blockNoise;float randY = randFibo(vec2(sin(floorY + offset + phase), 0.5));\nfloat randX = randFibo(vec2(cos(floorX + offset + phase), 0.5));\nfloat glitchModX = max(0.005, sign(randY - 0.5 - (1. - 0.1800*2.)/2.));\nfloat glitchModY = max(0.005, sign(randX - 0.5 - (1. - 0.1800*2.)/2.));float randOffX = randFibo(vec2(floorY + offset * glitchModX + phase, 0.7));\nfloat randOffY = randFibo(vec2(floorX + offset * glitchModY + phase, 0.9));\nfloat offX = (randOffX * offsetX - offsetX/2.)/5.;\nfloat offY = (randOffY * offsetY - offsetY/2.)/5.;offX = clamp(offX, -1.0, 1.0);\noffY = clamp(offY, -1.0, 1.0);uv.x = mix(uv.x, uv.x + offX * 2., glitchModX);\nuv.y = mix(uv.y, uv.y + offY * 2., glitchModY);float waveFreq = 30.0;\nfloat waveAmp = 0.005 * 0.0900;\nfloat timeOffset = uTime * 0.05;\nfloat sinY = sin((uv.y + 0.0100) * waveFreq * (1. - 0.0300) * 2. + timeOffset);\nfloat rogue = smoothstep(0., 2., sinY - 0.5) * 0.2 * 0.0900;\nfloat sinWaveX = sin(uv.y * waveFreq + uTime);\nfloat sinWaveY = sin(uv.x * waveFreq + uTime);\nuv.x += sinWaveX * waveAmp + rogue;\nuv.y += sinWaveY * waveAmp;\nfloat waveX = sinWaveX * waveAmp + rogue * chromab * 0.2;uv = clamp(uv, vec2(0.005), vec2(0.995));vec4 color = texture(uTexture, uv);vec2 redOffset = vec2(\nclamp(uv.x + (glitchModX * -offX * chromab - waveX), 0.005, 0.995),\nclamp(uv.y + (glitchModX * -offY * chromab), 0.005, 0.995)\n);\nvec2 blueOffset = vec2(\nclamp(uv.x + (glitchModX * offX * chromab + waveX), 0.005, 0.995),\nclamp(uv.y + (glitchModX * offY * chromab), 0.005, 0.995)\n);color.r = texture(uTexture, redOffset).r;\ncolor.b = texture(uTexture, blueOffset).b;\nfragColor = color;}"
            ],
            "compiledVertexShaders": [
                "#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"
            ],
            "data": {
                "depth": false,
                "uniforms": {},
                "isBackground": false
            },
            "id": "glitch"
        }
    ],
    "options": {
        "name": "YourWeb Final (Remix)",
        "fps": 60,
        "dpi": 1.5,
        "scale": 1,
        "includeLogo": false,
        "isProduction": false
    },
    "version": "2.0.5",
    "id": "ohmse2RtGXKWtXNOL98B"
}